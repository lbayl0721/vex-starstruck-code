#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    LauncherPot,    sensorPotentiometer)
#pragma config(Sensor, in2,    autonselector,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  BaseEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl11, BaseRearEncoder, sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           LeftClaw,      tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           LaunchBR,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port3,           LaunchTL,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightrear,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rightfront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           LaunchTR,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftfront,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           LaunchBL,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           leftrear,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          RightClaw,     tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
//////////////////////////////////////////////////////////////////////
#include "Vex_Competition_Includes.c"
#define DEADBAND 15
#define LIFT_SPEED 120
#define LIFT_SLOW 100
#define LIFT_UP true
#define LIFT_DOWN false
#define LIFT_HALF true
#define LIFT_FULL false



/////////////////////////////////////////////////////////////////////////////
const int MOTOR_NUM =         kNumbOfTotalMotors;
#define MOTOR_MAX_VALUE         127
#define MOTOR_MIN_VALUE         (-127)
#define MOTOR_DEFAULT_SLEW_RATE 10      // Default will cause 375mS from full fwd to rev
#define MOTOR_FAST_SLEW_RATE    256     // essentially off
#define MOTOR_TASK_DELAY        15      // task 1/frequency in mS (about 66Hz)
#define MOTOR_DEADBAND          10
// Array to hold requested speed for the motors
int motorReq[ MOTOR_NUM ];

// Array to hold "slew rate" for the motors, the maximum change every time the task
// runs checking current mootor speed.
int motorSlew[ MOTOR_NUM ];
/////////////////////////////////////////////////////////////////////////
task MotorSlewRateTask()
{
    int motorIndex;
    int motorTmp;

    // Initialize stuff
    for(motorIndex=0;motorIndex<MOTOR_NUM;motorIndex++)
        {
        motorReq[motorIndex] = 0;
        motorSlew[motorIndex] = MOTOR_DEFAULT_SLEW_RATE;
        }

    // run task until stopped
    while( true )
        {
        // run loop for every motor
        for( motorIndex=0; motorIndex<MOTOR_NUM; motorIndex++)
            {
            // So we don't keep accessing the internal storage
            motorTmp = motor[ motorIndex ];

            // Do we need to change the motor value ?
            if( motorTmp != motorReq[motorIndex] )
                {
                // increasing motor value
                if( motorReq[motorIndex] > motorTmp )
                    {
                    motorTmp += motorSlew[motorIndex];
                    // limit
                    if( motorTmp > motorReq[motorIndex] )
                        motorTmp = motorReq[motorIndex];
                    }

                // decreasing motor value
                if( motorReq[motorIndex] < motorTmp )
                    {
                    motorTmp -= motorSlew[motorIndex];
                    // limit
                    if( motorTmp < motorReq[motorIndex] )
                        motorTmp = motorReq[motorIndex];
                    }

                // finally set motor
                motor[motorIndex] = motorTmp;
                }
            }

        // Wait approx the speed of motor update over the spi bus
        wait1Msec( MOTOR_TASK_DELAY );
        }
}
/////////////////////////////////////////////////////////////////////////
void
DriveLeftfrontMotor( int speed )
{
    motorReq[leftfront] = speed;
}

void
DriveLeftrearMotor( int speed )
{
    motorReq[leftrear] = speed;
}

void
DriverightfrontMotor( int speed )
{
    motorReq[rightfront] = speed;
}

void
DriverightrearMotor( int speed )
{
    motorReq[rightrear] = speed;
}
//////////////////////////////////////////////////////////////////////////////////////







void opSetDrive(int upperRight, int upperLeft, int lowerRight, int lowerLeft);
void forwardsBackwards (int speed);
void strafe (int speed);
void turn (int speed);																//right is positive, left is negative
void backWheelTurn (int speed);
void lift (bool direction, bool halfSpeed);
void throw (int power);
int scaleJoystick (int input);



//////////////////////////////////////////////////////////////////////////////////////////////////////////////
task holdarm()
{
	while (true)
		{
			if (SensorValue[LauncherPot] <= 1300)
		{
			motor[LaunchBL] = 60;
			motor[LaunchTL] = -60;
			motor[LaunchTR] = 60;
			motor[LaunchBR] = -60;
		}
			else
			if (SensorValue[LauncherPot] > 1300 && SensorValue[LauncherPot] < 1500)
		{
			motor[LaunchBL] = 30;
			motor[LaunchTL] = -30;
			motor[LaunchTR] = 30;
			motor[LaunchBR] = -30;
		}
		else
		{
			motor[LaunchBL] = 0;
			motor[LaunchTL] = 0;
			motor[LaunchTR] = 0;
			motor[LaunchBR] = 0;
		}
		}
}
////////////////////////////////////////////////////////////////////////////////////////
task holdcube()
{
	while (true)
		{
			if (SensorValue[LauncherPot] <= 1600)
		{
			motor[LaunchBL] = 50;
			motor[LaunchTL] = -50;
			motor[LaunchTR] = 50;
			motor[LaunchBR] = -50;
		}
			else
			if (SensorValue[LauncherPot] > 1600 && SensorValue[LauncherPot] < 1800)
		{
			motor[LaunchBL] = 30;
			motor[LaunchTL] = -30;
			motor[LaunchTR] = 30;
			motor[LaunchBR] = -30;
		}
		else
		{
			motor[LaunchBL] = 0;
			motor[LaunchTL] = 0;
			motor[LaunchTR] = 0;
			motor[LaunchBR] = 0;
		}
		}
}
////////////////////////////////////////////////////////////////////////////////////////////
task opentippeg()
{
	while(SensorValue[LauncherPot] < 1400)
	{
		motor[LaunchBL] = 70;
		motor[LaunchTL] = -70;					//raise the arm to release the tip peg
		motor[LaunchTR] = 70;
		motor[LaunchBR] = -70;
	}
		motor[LaunchBL] = -60;
		motor[LaunchTL] = 60;       //lower arm at half speed
		motor[LaunchTR] = -60;
		motor[LaunchBR] = 60;
	wait1Msec(400);
	throw(-20);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////
task holdtongsdown ()
{
		throw(-30);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
task tongHover ()
{
	while (true)
	{
		if (SensorValue[LauncherPot] > 1600 && SensorValue[LauncherPot] < 3500)
		{
			motor[LaunchBL] = -60;
			motor[LaunchTL] = 60;
			motor[LaunchTR] = -60;
			motor[LaunchBR] = 60;
		}
		else
		if (SensorValue[LauncherPot] > 1275 && SensorValue[LauncherPot] < 1600)
		{
			motor[LaunchBL] = -25;
			motor[LaunchTL] = 25;
			motor[LaunchTR] = -25;
			motor[LaunchBR] = 25;
		}
		else
		{
			motor[LaunchBL] = 0;
			motor[LaunchTL] = 0;
			motor[LaunchTR] = 0;
			motor[LaunchBR] = 0;

		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void pre_auton()
{

	bStopTasksBetweenModes = true;
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////



task autonomous()
{
if (SensorValue[autonselector] < 3000 && SensorValue[autonselector] > 1000)
{
startTask(opentippeg);
while(SensorValue[BaseEncoder] < 600 && SensorValue[BaseRearEncoder] < 600)
	{
	strafe(-70);											//strafe to the left to have room to open tip peg and arm
	}
	strafe(0);
	  SensorValue[BaseEncoder] = 0;
	  SensorValue[BaseRearEncoder] = 0;


while(SensorValue[BaseEncoder] > -700 && SensorValue[BaseRearEncoder] > -700)
	{
		forwardsBackwards(70);	//move forwards under the cube
	}
		forwardsBackwards(0);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;				//reset encoder values
stopTask(opentippeg);
		while(SensorValue[BaseEncoder] < 1050 && SensorValue[BaseRearEncoder] < 1050)
	{
		backWheelTurn (100);			//make a 90 degree turn to be ready to throw the first cube
	}
		backWheelTurn(-10);
		wait1Msec(100);
		turn(0);

	while(SensorValue[LauncherPot] < 2800)
	{
		throw(100);    //throw cube
	}
	throw(0);
	wait1Msec(400);
startTask(tongHover);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
	while(SensorValue[BaseEncoder] > -500 && SensorValue[BaseRearEncoder] > -500)
	{
	strafe(60);											//strafe a little to the right to make sure to get the furthest right star along the back wall
	}
	strafe(0);
wait1Msec(50);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
	stopTask(tongHover);
	startTask(holdtongsdown);
	while(SensorValue[BaseEncoder] > -750 && SensorValue[BaseRearEncoder] > -750)
	{
		forwardsBackwards(100);			//move forwards to the wall under the stars
	}
		forwardsBackwards(0);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
	wait1Msec(50);
	stopTask(holdtongsdown);
	startTask(holdarm);
	wait1Msec(300);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
		while(SensorValue[BaseEncoder] < 570 && SensorValue[BaseRearEncoder] < 570)
	{
		forwardsBackwards(-90);			//move backwards to middle of field
	}
		forwardsBackwards(0);
		stopTask(holdarm);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
	while(SensorValue[LauncherPot] < 3000)
	{
		throw(90); //throw the first set of back wall stars
	}

		throw(0);

startTask(tongHover);
wait1Msec(500);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
	while(SensorValue[BaseEncoder] < 450 && SensorValue[BaseRearEncoder] < 450)
	{
		strafe(-80);								//strafe to the left to go under the other star
	}
		strafe(0);
	wait1Msec(50);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
	stopTask(tongHover);
	startTask(holdtongsdown);
	while(SensorValue[BaseEncoder] > -800 && SensorValue[BaseRearEncoder] > -850)
	{
		forwardsBackwards(100);						//move forwards underneath the star
	}
		forwardsBackwards(0);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
	wait1Msec(50);
	stopTask(holdtongsdown);
	startTask(holdarm);
	wait1Msec(300);
		while(SensorValue[BaseEncoder] < 570 && SensorValue[BaseRearEncoder] < 570)
	{
		forwardsBackwards(-90);			//move backwards to middle of field
	}
		forwardsBackwards(0);
		stopTask(holdarm);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
	while(SensorValue[LauncherPot] < 2800)
	{
		throw(70); //throw the second set of back wall stars
	}

	throw(0);

	wait1Msec(400);

/*	throw(-60); //lower arm to the ground
	wait1Msec(1000);

	throw(0);
	wait1Msec(50);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0; */

}
////////////////////////////////////////////////////////////////////////////
else
	if (SensorValue[autonselector] >= 3000)									//left side alternate auton
	{
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
		while(SensorValue[BaseEncoder] > -300 && SensorValue[BaseRearEncoder] > -300)
		{
		strafe(60);											//strafe a little to the right to knock off the preload
		}
		strafe(0);
		wait1Msec(50);
		strafe(-60);
		wait1Msec(200);
		strafe(0);
	startTask(opentippeg);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
		while(SensorValue[BaseEncoder] < 950 && SensorValue[BaseRearEncoder] < 950)
	{
		forwardsBackwards(-90);			//move backwards to middle of field
	}
		forwardsBackwards(0);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
	stopTask(opentippeg);
	startTask(tongHover);
strafe(60);
wait1Msec(1200);  //strafe to the right to ralign against the wall
strafe(0);
		wait1Msec(50);
		strafe(-40);
		wait1Msec(300);									//strafe back to the left to avoid hanging pole
		strafe(0);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
stopTask(tongHover);
startTask(holdtongsdown);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
	while(SensorValue[BaseEncoder] > -725 && SensorValue[BaseRearEncoder] > -725)
	{
		forwardsBackwards(100);			//move forwards to the wall under the stars
	}
		forwardsBackwards(0);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
	wait1Msec(50);
	stopTask(holdtongsdown);
	startTask(holdarm);
	wait1Msec(300);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
		while(SensorValue[BaseEncoder] < 520 && SensorValue[BaseRearEncoder] < 520)
	{
		forwardsBackwards(-90);			//move backwards to middle of field
	}
		forwardsBackwards(0);
		stopTask(holdarm);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
	while(SensorValue[LauncherPot] < 3000)
	{
  throw(100);
	}

	throw(0);

	wait1Msec(200);

	motor[LaunchBL] = -60;
	motor[LaunchTL] = 60;             // Lift Down Slow to the bottom for 1000 msec
	motor[LaunchTR] = -60;
	motor[LaunchBR] = 60;
	wait1Msec(500);

	throw(0);

	}
////////////////////////////////////////////////////////////////////////////////////////////////////////
else
	if (SensorValue[autonselector] <= 1000)									//right side alternate auton
	{
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
		while(SensorValue[BaseEncoder] < 300 && SensorValue[BaseRearEncoder] < 300)
		{
		strafe(-60);											//strafe a little to the left to knock off the preload
		}
		strafe(0);
		wait1Msec(50);
		strafe(60);
		wait1Msec(300);
		strafe(0);
	startTask(opentippeg);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
		while(SensorValue[BaseEncoder] < 950 && SensorValue[BaseRearEncoder] < 950)
	{
		forwardsBackwards(-90);			//move backwards to middle of field
	}
		forwardsBackwards(0);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
	stopTask(opentippeg);
	startTask(tongHover);
	strafe(-60);
	wait1Msec(1200);  //strafe to the left to ralign against the wall
	strafe(0);
	wait1Msec(50);
	strafe(40);
	wait1Msec(300);									//strafe back to the right to avoid hanging pole
	strafe(0);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
stopTask(tongHover);
startTask(holdtongsdown);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
	while(SensorValue[BaseEncoder] > -725 && SensorValue[BaseRearEncoder] > -725)
	{
		forwardsBackwards(100);			//move forwards to the wall under the stars
	}
		forwardsBackwards(0);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
	wait1Msec(50);
	stopTask(holdtongsdown);
	startTask(holdarm);
	wait1Msec(300);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
		while(SensorValue[BaseEncoder] < 520 && SensorValue[BaseRearEncoder] < 520)
	{
		forwardsBackwards(-90);			//move backwards to middle of field
	}
		forwardsBackwards(0);
		stopTask(holdarm);
	SensorValue[BaseEncoder] = 0;
	SensorValue[BaseRearEncoder] = 0;
	while(SensorValue[LauncherPot] < 3000)
	{
		throw(100);
	}

	throw(0);

	wait1Msec(200);

	motor[LaunchBL] = -60;
	motor[LaunchTL] = 60;             // Lift Down Slow to the bottom for 1000 msec
	motor[LaunchTR] = -60;
	motor[LaunchBR] = 60;
	wait1Msec(500);

	throw(0);

	}
/////////////////////////////////////////////////////////////////////////////

	AutonomousCodePlaceholderForTesting();
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
 int buttonToggleState = 0;
 int buttonPressed = 0;
 bool Arm_Down_Off;
	// User control code here, inside the loop
startTask(MotorSlewRateTask);
	while (true)
	{
		int channel3 = scaleJoystick (vexRT[Ch3]);
		int channel4 = scaleJoystick (vexRT[Ch4]);
		int channel1 = scaleJoystick (vexRT[Ch1]);
		int upperLeft = channel3 + channel1 + channel4;
		int upperRight = channel3 - channel1 - channel4;
		int lowerLeft = channel3 + channel1 - channel4;
		int lowerRight = channel3 - channel1 + channel4;


		DriveLeftfrontMotor(upperLeft);
		DriveLeftrearMotor(lowerLeft);
		DriverightfrontMotor(upperRight);
		DriverightrearMotor(lowerRight);


		if(vexRT[Btn6D] == 1)
		{
			lift(LIFT_UP,LIFT_FULL);
			stopTask(holdarm);
		}
		else
			if(vexRT[Btn6U] == 1)
		{
			lift(LIFT_UP,LIFT_HALF);
			stopTask(holdarm);
		}
		else
			if(vexRT[Btn5U] == 1)
		{
			lift(LIFT_DOWN, LIFT_HALF);
			stopTask(holdarm);
		}
		else
			if(vexRT[Btn5D] == 1)
		{
			startTask(holdarm);
		}
		else
			if (SensorValue[LauncherPot] > 1275 && SensorValue[LauncherPot] < 1600 && vexRT[Btn5U] == 0 && vexRT[Btn5D] == 0 && vexRT[Btn6U] == 0 && vexRT[Btn6U] == 0 && Arm_Down_Off == true)
		{
			motor[LaunchBL] = -25;
			motor[LaunchTL] = 25;
			motor[LaunchTR] = -25;
			motor[LaunchBR] = 25;
			stopTask(holdarm);
		}
		else
		{
			motor[LaunchBL] = 0;
			motor[LaunchTL] = 0;
			motor[LaunchTR] = 0;
			motor[LaunchBR] = 0;
			stopTask(holdarm);
		}
				if(SensorValue[LauncherPot] > 2200)
				{
					buttonToggleState = 1;
				}
				else
				// check for a button press only if we are not already pressed.
        if( vexRT[ Btn8L ] == 1 )
            {
            if( ! buttonPressed )
              {
              // change the toggle state
              buttonToggleState = 1 - buttonToggleState;

              // Note the button is pressed
              buttonPressed = 1;
              }
            }
        else
            {
            // the button is not pressed
            buttonPressed = 0;
            }


        // Now do something with our toggle flag
        if( buttonToggleState )
            Arm_Down_Off = true;
        else
            Arm_Down_Off = false;
     }
}

void opSetDrive(int upperRight, int upperLeft, int lowerRight, int lowerLeft)
{
	motor[leftfront] = upperLeft;
	motor[leftrear] = lowerLeft;
	motor[rightfront] = upperRight;
	motor[rightrear] = lowerRight;
}
void forwardsBackwards (int speed)
{
	opSetDrive (speed,speed,speed,speed);
}
void strafe (int speed)
{
	opSetDrive (-speed,speed,speed,-speed);
}
void turn (int speed)
{
	opSetDrive (-speed,speed,-speed,speed);
}
void backWheelTurn (int speed)
{
	opSetDrive (0,0,-speed,speed);
}
void throw (int power)
	{
		motor[LaunchBL] = power;
		motor[LaunchTL] = -power;
		motor[LaunchTR] = power;
		motor[LaunchBR] = -power;
	}
void lift (bool direction, bool halfSpeed)
{
	if (direction && halfSpeed)
	{
		motor[LaunchBL] = LIFT_SLOW;
		motor[LaunchTL] = -LIFT_SLOW;
		motor[LaunchTR] = LIFT_SLOW;           //Lift Up Slow
		motor[LaunchBR] = -LIFT_SLOW;
	}
	else
		if (!direction && halfSpeed)
	{
		motor[LaunchBL] = -70;
		motor[LaunchTL] = 70;             // Lift Down Slow
		motor[LaunchTR] = -70;
		motor[LaunchBR] = 70;
	}
	else
		if (direction && !halfSpeed)
	{
		motor[LaunchBL] = LIFT_SPEED;
		motor[LaunchTL] = -LIFT_SPEED;             // Lift Up Fast
		motor[LaunchTR] = LIFT_SPEED;
		motor[LaunchBR] = -LIFT_SPEED;
	}
	else
		if (!direction && !halfSpeed)
	{
		motor[LaunchBL] = -LIFT_SPEED;
		motor[LaunchTL] = LIFT_SPEED;             // Lift Down Fast
		motor[LaunchTR] = -LIFT_SPEED;
		motor[LaunchBR] = LIFT_SPEED;
	}
}
int scaleJoystick (int input)
{
	if(input > DEADBAND)
		return input;
	else
		if (input < -DEADBAND)
		return input;
	else
		return 0;
}
